00 Introduction
14-Sep-2017


TERMINOLOGY


Move semantics
C++11 most pervasive feature
The foundation of move semantics is distinguishing rvalue expressions from lvalue expressions

rvalues indicate objects eligible for move operations
lvalues generally don't!

rvalues : temporary objects returned from functions
lvalues : objects you can refer to by name, by following a pointer or lvalue reference


Q.
Can you take an object's address?
Yes		lvalue
No		rvalue


NB:
Type of an expression is independent of whether expression is lvalue or rvalue
Give type T, you can have lvalues of type T and rvalues of type T

IMPORTANT
Remember this when dealing with a parameter of rvalue reference type [Widget&& rhs]
because the [function] parameter itself is an lvalue


Example
class Widget
{
public:
	Widget( Widget&& rhs );		// rhs parameter is an lvalue although
								// it has an rvalue reference [&&]type
};


rhs parameter is an lvalue 
ALL parameters are lvalues 		[because you can take rhs address]


Parameters vs. Arguments

Parameters
void someFunc( Widget w );		// w is the function parameter


Arguments
Widget wid;
someFunc( wid );				// wid is argument
someFunc( std::move( wid ) )	// std::move(wid) is the argument





void someFunc(Widget w)

Widget wid;
someFunc(wid);
wid is argument



Move operations		move constructor	move assignment
Copy operations		copy constructor	copy assignment